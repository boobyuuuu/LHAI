#!/home/innov2023/miniconda3/envs/workshop/bin/python3.11
import os
import sys
import warnings
from pathlib import Path
import threeML
from hawc_hal import HAL, HealpixConeROI
import healpy as hp
import numpy as np
from astropy.io import fits
from astropy.wcs import WCS
from astropy.wcs.wcs import WCS
from astropy.wcs.utils import pixel_to_skycoord
from astromodels import *
import numpy as np
import matplotlib.pyplot as plt
import astropy.units as u
import collections
from hawc_hal.maptree.data_analysis_bin import DataAnalysisBin
from hawc_hal.maptree.map_tree import MapTree
from hawc_hal.healpix_handling import (FlatSkyToHealpixTransform,
                                       SparseHealpix, get_gnomonic_projection)
import pandas as pd
from pandas import HDFStore
# import matplotlib



def respconv(
    fitsfile, map_tree, det_res,mapname ,
    xsize, srcname='src',
    plindex=2.63, piv=1e12, specK=2.5e-13,
    bins='0', PLOT=False
            ):
    '''
    fitsfile:  str, path of fits file
    map_tree: str
    det_res: str
    mapname: str, hd5 file path

    xsize: int, width of the final map (2darray)
    srcname: Optional, str

    plindex: float, powerlaw index. Positive.
    piv: float, pivot value of powerlaw spectrum, unit in eV.
    specK: spectrum normalization, total flux, in erg/cm^2/s

    bins: str, '0' - '5'. currently only a single energy bin is supported. 
    '''

    # astromodels.ExtendedSource
    # with spectral shape (powerlaw)
    # and spatial shape, which could be regular functions, e.g. disk, halo, ellipse etc. 
    # Here we specify the template generated by our own simulations, 
    # which utilizes te SpatialTemplate_2D method. This method requires data stored in 
    # FITS file with WCS coordinate.

    # ----------------setup template------------------------
    # ------spatial template-------
    srctemplate = SpatialTemplate_2D(fits_file=fitsfile)

    # ------spectral template-------
    spectrum = threeML.Powerlaw()
    spectrum.index.value  = plindex
    spectrum.index.fix    = True

    spectrum.piv.value    = piv #* threeML.u.TeV
    spectrum.piv.fix      = True

    spectrum.K.value      = specK #* fluxUnit
    spectrum.K.fix        = True

    # -------define source-----------
    src = ExtendedSource(srcname,
                     spectral_shape=spectrum, 
                     spatial_shape =srctemplate)
    
    
    # specify the source loation here
    hdulist = fits.open(fitsfile)
    header = hdulist[0].header

    # automatically read radius, ra, dec from fits header
    roi_radius = header['NAXIS1'] * header['CDELT2'] / 2
    roi_ra, roi_dec = (header['CRVAL1'], header['CRVAL2'])
    roi_pw = header['CDELT2']  # in degree
    resolution = roi_pw * 60

    # Model class (self, *source), where source could be a list of srcs.
    # Only one src here.
    model = threeML.Model(src)

    # this is required by convolution (padding)
    roi_radius_model = roi_radius + 5

    roi = HealpixConeROI(
        data_radius=roi_radius, model_radius=roi_radius_model, ra=roi_ra, dec=roi_dec
    )
    like = HAL("HAWC", map_tree, det_res, roi, flat_sky_pixels_size=header['CDELT2'])
    # specify energy bin
    like.set_active_measurements(bin_list=bins)
    # model.display(complete=True)
    like.set_model(model)
    # finish simulating
    like.get_log_like()
    
    like.write_model_map(mapname, poisson_fluctuate=True)
    
    convolved = HDFStore(mapname)
    anabin = convolved['/analysis_bins']
    convolvedmap = np.zeros(1024**2 * 12)
    index = [anabin.index[i][1] for i in range((anabin.shape[0]))]
    excess = anabin.values[:,0]-anabin.values[:,1]
    convolvedmap[index] = excess
    convolved.close()

    
    img = selectreg(convolvedmap,roi_ra, roi_dec, roi_pw * xsize / 2, 1024,
                Equat=True, dpar=30, dmer = 30, cmap='viridis', xsize=xsize, plot=False)

    return img



def data2fits(data, ra, dec, filename, xsize_fin, pixelw=0.1):
    '''
        data: 2darray, lenx and leny should be the same
        ra: float, the right ascension of central pixel, range: [0, 360] deg
        dec: float, the declination of central pixel, range: [-90, 90] deg
        filename: filename of the saved fits file
        pixelw: float, width of each pixel, in degree.
    '''

    data = data / (np.sum(data) * (pixelw / 180 * np.pi)**2)
    assert data.ndim == 2, 'data is not a 2d array!'
    wid_x, wid_y = data.shape

    wcs = WCS(naxis=2)
    wcs.wcs.crpix = [int(wid_x / 2), int(wid_y / 2)]  # center of map
    wcs.wcs.cdelt = np.array([-pixelw, pixelw])  #
    wcs.wcs.crval = [ra, dec]            # ra, dec of central pixel
    wcs.wcs.ctype = ["RA---AIR", "DEC--AIR"]  # proection

    header = wcs.to_header()
    header['BUNIT'] = '1 / deg2'
    header['CUNIT1'] = 'deg'
    header['CUNIT2'] = 'deg'

    hdu = fits.PrimaryHDU(data, header=header)
    hdu.writeto(filename, overwrite=True)
    cp = int(data.shape[0]/2)
    hp = int(xsize_fin/2)
    return data[cp-hp:cp+hp,cp-hp:cp+hp]

def selectreg(ma,ra,dec,radius,NSIDE,Equat=True,dpar=30,dmer = 30,cmap='jet',xsize=800,plot=True):
    '''
    select a region with one center and one radius, and convert it to cartesian coordinate.
    
    input:
        ma, map of all sky
        ra, dec: float or arraylike, in degree. 
        radius, the radius of ROI in degrees
        NSIDE, resolution of healpy grafic.
        Equat=True, coord of target plot
        dpar,dmer, density of reference line
        cmap='jet'
        xsize = 800, the final size of img
    output:
        selected image, 2darray
        '''

    vec = hp.ang2vec(ra,dec,lonlat=True)
    pix_select = hp.query_disc(NSIDE,vec,radius)
    region = ma[pix_select]
    lonra = [-radius,+radius]
    latra = [-radius,+radius]
    if Equat:
        coord = 'C'
    else:
        coord = 'G'
    img = hp.cartview(region,
                      coord=coord,
                      rot=(ra,dec),
                      lonra=lonra,
                      latra=latra,
                      return_projected_map=True,
                      cmap=cmap,
                      min = region.min(),
                      max = region.max(),
                      xsize=xsize
                     )
    hp.graticule(dpar = dpar,dmer = dmer)
    # plotGala(coord)
    if plot == False:
        plt.close('all')

    return img


if __name__ == "__main__":

    fitsfile = './fits/Einstein.fits'
    map_tree = '../res_file/map_20240731_WCDA.root'
    det_res = '../res_file/res_20240731_WCDA.root'

    data = np.load('rc.npy')
    data2fits(data, 0, 0, fitsfile, pixelw=0.1)

    xsize = 64
    img = respconv(
        fitsfile, map_tree, det_res,
        xsize, srcname='src',
        plindex=2.63, piv=1e12, specK=2.5e-13,
        bins='0', PLOT=False
            )
    plt.figure()
    plt.imshow(img)
    plt.colorbar()
    plt.show()
    plt.savefig('./plots/disconsphere.png')
